\chapter{Implementación}
El desarrollo del proyecto se llevó a cabo a través de una serie de etapas las cuáles se detallan a continuación. Las mismas incluyen distintos aspectos tales como descripción de las herramientas utilizadas (hardware y software), configuración necesaria de las mismas, implementación de la solución y finalmente experimentación con casos de prueba, incluyendo análisis de los resultados obtenidos.

\section {Autonomía de los drones}
Uno de los objetivos del proyecto es poder ejecutar la solución implementada de forma nativa en cada uno de los drones de forma tal que la flota pueda volar autónomamente sin la necesidad de una estación base que se esté en comunicación con ellos. En las siguientes secciones se detalla el trabajo realizado para cumplir con esta meta. 
\section {Herramientas de compilación}
El primer desafío encontrado fue el de implementar una solución que pueda ejecutarse en la arquitectura ARMv7 [19] que posee el dron Parrot Bebop 2, teniendo en cuenta que los equipos donde se desarrolla la solución están basados en la arquitectura x86 de los procesadores Intel.

Se plantean diferentes alternativas para solucionar este problema. La primera es la de realizar un cross-compile. Se entiende por cross compile la acción de compilar código en un sistema huésped que no tenga la misma arquitectura que el sistema objetivo en el cual se piensa ejecutar el programa, de esta forma se genera un ejecutable compatible con la arquitectura del sistema destino. En este proyecto, el sistema huésped son computadoras comunes de arquitectura x86 y el sistema destino es el dron con arquitectura ARMv7. Esta opción también incluye la utilización de compiladores específicos para la arquitectura de destino seleccionada. 

La segunda alternativa es la de utilizar el emulador Qemu [20-21] que permite la ejecución de sistemas operativos diseñados para arquitecturas diferentes a los del sistema anfitrión.
Por medio de Qemu es posible emular la arquitectura del dron, por lo que al momento de compilar no es necesario hacer uso de la técnica de cross compile dado que el ejecutable generado con la compilación por defecto va a ser compatible con el dron.

Como tercera opción se plantea utilizar una CPU que posea arquitectura ARM para que de ese modo, utilizando el mismo planteo que con el emulador Qemu, se pueda compilar directamente en la arquitectura destino sin necesidad de realizar el cross compile. Una de las opciones de CPU con arquitectura ARM más accesibles en el mercado es el de los dispositivos Raspberry Pi [22], los cuales permiten realizar todas las mismas acciones que con un PC tradicional.

Al momento de analizar las distintas alternativas se decidió utilizar la Raspberry Pi para compilar directamente en ella en lugar de hacer cross compile [23] o utilizar el emulador Qemu. Cross compile genera dificultades al momento de compilar cuando las librerías a utilizar (como por ejemplo el sdk del dron) requieren de muchas dependencias. Qemu, si bien otorga las mismas funcionalidades que la Raspberry Pi, tiene una complejidad mayor en cuanto a instalación y posterior configuración.
De todas formas, compilar e instalar en el dron resulta bastante complejo y consume mucho tiempo, por lo que se intentó minimizar la cantidad de programas a instalar en el dron.
\section {Lenguaje de programación}
Una de las tareas básicas para poder implementar una solución de este tipo es la de poder comunicarse con los drones mediante código en algún lenguaje de programación con el objetivo de darles órdenes para que realicen las acciones necesarias (despegue, aterrizaje, movimientos, etc). Existe un sdk oficial provisto por Parrot que permite realizar este tipo de tareas y que está disponible para distintos lenguajes de programación como C, Java, Objective C. Mediante el sdk se pueden realizar programas en cualquiera de estos lenguajes para darles órdenes a los drones pero con la limitante de que están pensados para que sean ejecutados en una terminal distinta al dron, ya sea una pc, smartphone, tablet, etc. Además, todos estos lenguajes son compilados.

Tanto en C, como en Java y Objective C se debe realizar una tarea de cross compile para ejecutar los programas en el dron o utilizar un intermediario como la Raspberry Pi y se debe hacer cada vez que se modifica el programa. Esto va en contra del principio establecido anteriormente de minimizar los cross-compiles. La solución a este problema vino dada por utilizar una librería para el lenguaje de programación Python llamada pyparrot la cual implementa una interfaz para el sdk oficial de Parrot. Python es un lenguaje de programación de scripting por lo que no es necesario compilar los programas desarrollados. Lo que se debe compilar es el intérprete de Python y algunas librerías que están escritas en C, sin embargo esto hay que hacerlo una única vez y luego se puede desarrollar el resto del programa sin tener que hacer más cross-compiles. De esta forma se procedió a usar la Raspberry Pi para generar ejecutables del intérprete de Python en ARM7. Finalmente se instaló esta versión compilada de Python en cada uno de los drones de forma que cada uno pudiese ejecutar de forma nativa los scripts en dicho lenguaje de programación. Esto permitió que se pudiese desarrollar el código directamente en equipos que no tuviesen arquitectura ARM y ejecutarse en el dron sin necesidad de realizar ninguna configuración extra.

\section {Conectividad entre los drones}
Como ya se mencionó, uno de los principales objetivos del proyecto es el de crear una flota de drones que sea completamente autónoma, es decir, que no necesite ningún equipamiento extra para funcionar. Por esta razón la primera opción para crear una red de comunicación entre los drones era la de crear una red ad-hoc. En una red ad-hoc todos los nodos de la red se encuentran en igualdad de condiciones (es decir que no hay un nodo central) y los nodos pueden seguir operando sin tener necesidad de estar conectados a toda la red (según el programa puede que ni siquiera sea necesario mantener una conexión con la red todo el tiempo). En el caso particular de la exploración de una zona con una flota de drones esto plantea varias ventajas. En primer lugar las redes ad-hoc permiten que los drones individuales sean completamente autónomos entre sí, incluso pueden seguir trabajando habiendo perdido toda conexión con el resto de la red (si bien esto implica que probablemente van a realizar su trabajo de forma menos eficiente). Además los drones pueden servir de relés para otros drones, por ejemplo, puede suceder que dos drones se encuentren muy lejos entre sí como para establecer una comunicación directa pero si existe un tercer dron que se encuentre en un punto intermedio entre ellos este puede servir de relé entre los dos. Esto aumenta de forma considerable el alcance que puede tener la red, lo cual aumenta el tamaño del área que se puede explorar de forma efectiva.

Debido a las ventajas descritas se analiza la posibilidad de implementar una red ad-hoc en los drones Bebop 2 pero los mismos no cuentan con una  tarjeta de red con soporte para el modo ad-hoc con la configuración por defecto. 
El modelo de la  tarjeta de red integrada en el dron es Broadcom BCM4360 [24], la cual en la configuración por defecto en los drones no permite asignar otros modos de conexión a la interfaz wifi distintos a Master y Managed. Los Bebop 2 vienen de fábrica con su interfaz configurada en modo Master, de esta forma cada dron publica su propia red wifi a la cual se pueden conectar otros dispositivos como teléfonos celulares o computadoras. Esta es la forma en la que los usuarios controlan a los drones normalmente.
Se investigó la posibilidad de incorporar modificaciones a los drivers que trae por defecto el dron pero la instalación de los mismos no es posible realizarla sin incorporar modificaciones riesgosas sobre el sistema operativo BusyBox que en caso de fallos puede llevar a errores irreparables en el funcionamiento del mismo. Debido a estos inconvenientes se determinó descartar la configuración de la red ad-hoc.

Finalmente se decidió usar en su lugar una red wifi. Este enfoque tiene algunas desventajas con respecto a las redes ad-hoc, la más importante es que en una red wifi los drones dependen de una infraestructura externa a ellos que mantenga la red. Sin embargo esta infraestructura no tiene porqué ser muy compleja, puede componerse por módems portátiles y routers ubicados en lugares estratégicos para cubrir la zona. Incluso puede llegar a componerse por teléfonos celulares.
Por otra parte, una red wifi tiene un alcance mucho mejor definido, por lo que resulta más fácil evitar las pérdidas de conexión con la red.
Además, un dron conectado a la red debería ser capaz de establecer conexiones con cualquier otro dron conectado, sin importar la distancia entre ellos. Esto permite establecer comunicaciones a gran distancia sin necesidad de recurrir al uso de otros drones como relés, que si bien es una técnica muy útil, también resulta más difícil de gestionar.

Para implementar esta red en los drones hubo que realizar ciertas modificaciones en su configuración. En primer lugar se cambió el modo de la interfaz a Managed, para que todos los drones puedan estar conectados a la misma red. Luego se le configura a cada uno una dirección IP, el nombre del Punto de Acceso y su contraseña. Para que esta configuración no interfiera el funcionamiento por defecto del dron con aplicaciones que desean conectarse a su interfaz wifi se instala un script en el mismo que permite cambiar el modo de la interfaz al presionar 3 veces el botón de apagado del dron.
De esta forma se consigue que todos los drones pertenecientes a la flota de exploración formen parte de la misma red permitiendo establecer un canal de comunicación entre los mismos.

\section {Control de posicionamiento}
Uno de los principales desafíos encontrados es el de geo-localizar a los drones. Este requisito es fundamental para poder determinar la zona en la que se encuentra cada dron durante la exploración y así poder determinar el siguiente movimiento a realizar y comunicarle al resto de la flota su posición actual. Además contar con un posicionamiento preciso del dron permite la evasión de los obstáculos estáticos que existen en el territorio garantizando la seguridad del dron en todo momento.
Desafortunadamente el dron Parrot Bebop 2 no cuenta con sensores de distancia (salvo el que tiene para medir la altura de vuelo) que serían útiles para determinar la posición relativa con respecto a puntos conocidos del escenario y evitar todo tipo de obstáculos que se interpongan en la trayectoria de vuelo planificada. Tampoco es posible acceder a la información del acelerómetro ni del giroscopio para realizar cálculos relativos en función de los datos obtenidos por estos dispositivos.
Para resolver este problema se analizan diferentes alternativas las cuales se describen a continuación.
\subsection {Ubicación relativa a  movimientos}
Esta estrategia se basa en determinar la posición del dron en función de la ubicación del  punto de partida y un registro de los desplazamientos realizados. Esta medida es posible realizarla dado que el dron cuenta con una función de movimiento donde se indica la cantidad de metros a recorrer.
Al utilizar este enfoque se consigue determinar la ubicación del dron sin necesidad de emplear sensores ni artefactos externos, pero cuenta con la principal desventaja de que se depende de la precisión de los movimientos realizados. Al no existir
\subsection {Ubicación por GPS}
Los drones Bebop 2 cuentan con un sensor GPS el cual cumple con el objetivo de establecer la posición aproximada del dron al manejarlo de forma manual permitiendo encontrarlo en caso de extravíos.
La información sobre este sensor es accesible vía pyparrot pudiendo determinar la ubicación en función de su latitud y longitud.
El uso de este dispositivo tiene varios puntos en contra entre los que se destacan el hecho de que es necesario que el vuelo se realice en espacios abiertos sin interferencias de árboles o edificios, además de depender del clima dado que si está nublado se debilita la señal. Además tiene un rango de error de 5 metros y la posición no se actualiza en tiempo real sino que tiene un retardo que alcanza los 5 segundos.
\subsection {Ubicación por señal Wifi}
Es posible establecer la ubicación de un dispositivo con interfaz wifi en función de la intensidad de la señal de los puntos de acceso cercanos y la ubicación de estos. Este sistema de posicionamiento se denominado WPS [25] (Wi-Fi Positioning System) y se basa en un mecanismo de ubicación por trigonometría similar al usado por los GPS. Los sistemas WPS evalúan la intensidad de la señal recibida de los puntos de acceso cercanos y si se conoce la intensidad en el origen de la señal y la tasa a la que esa intensidad decae en función a la distancia se puede estimar la distancia al origen de esas señales. Si se conoce la ubicación de los puntos de acceso y se combina la información de por lo menos tres de estos un dispositivo puede estimar su propia posición usando trigonometría.
Como ya se mencionó, en teoría solo se necesitan tres puntos de acceso para estimar una posición, pero en la práctica se recomienda usar por lo menos cinco ya que esto aumenta notablemente la precisión de la estimación.
Las grandes empresas tecnológicas poseen bases de datos en las que almacenan información referente a la ubicación, la intensidad original y la tasa de decaimiento de la señal de miles de millones de puntos de acceso en todo el mundo. Esta información es usada comúnmente en aplicaciones comerciales de localización y se combina con la información del GPS para obtener mejores resultados.
Esto brinda dos opciones, en primer lugar se puede optar por usar estas bases de datos para complementar la información del GPS del dron o directamente se puede utilizar la información de puntos de acceso conocidos para implementar un sistema de ubicación propio.
Sin embargo existen limitantes con los dos métodos, en primer lugar la mayoría de las bases de datos de puntos de acceso no son públicas y las que sí lo son no brindan servicios gratuitos que sean precisos: ofrecen una longitud y latitud con una precisión de dos cifras después de la coma, lo que equivale a un área aproximada de 1 km2. Lo cual es inusable [26].
La otra opción de implementar un sistema de ubicación propio en base a puntos de acceso conocidos, tiene el potencial de ser muy precisa. Existen trabajos que demuestran que se pueden usar estos sistemas para tener una precisión en la ubicación en el orden de los decímetros, sin embargo estos métodos requieren de equipamiento del que el Bebop 2 no dispone. En particular se requiere que el dron posea tres antenas para disminuir el efecto multipath, en el cual una misma señal de wifi puede rebotar en varios obstáculos y entonces llegar al destino por diferentes caminos que toman diferentes cantidades de tiempo en ser recorridos.
Después de algunas pruebas preliminares y debido a estas limitantes se optó por no seguir este enfoque.
\subsection {Ubicación por procesamiento de imágenes}
Dada la falta de sensores de distancia equipados en el dron una alternativa posible es la de procesar las imágenes obtenidas por la cámara para determinar en función de objetos conocidos la ubicación del dron en el espacio.
Para esto se puede emplear una técnica basada en marcadores en la cual se los coloca a los mismos en puntos estratégicos por lo que al detectarlos con la cámara se reconoce la ubicación del dron.
Esta estrategia ha demostrado ser precisa pero tiene como desventaja que se necesita de la colocación de los marcadores en el territorio a explorar sumado al costo de recursos en el dron al tener que procesar las imágenes.
